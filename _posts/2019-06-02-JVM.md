---
layout: post
title: JVM
date: 2020-11-18
Author: shope
categories: 
tags: [JVM, ClassLoad]
comments: true
---

## 一、类加载过程

1、加载：将字节码加载到内存（此处的“**加载**”和“**类加载**”的关系为：类加载包含加载，加载是类加载过程的一个阶段）

​		期间调用**类加载器**对需要的Class进行加载；

2、验证：验证是否为字节码文件（.class）、字节码文件头是否为[cafe babe]、字节码等内容。

3、准备：给类变量分配**内存空间**，并赋予默认值。

4、解析：对类的静态变量初始化的值，执行静态代码块。

5、初始化：初始化类变量和其他资源，即给类变量设置成程序员设定的值（eg: int a = 123;）。

## 二、类加载器

- 引导类加载器：负责加载支撑JVM运行的位于JRE的lib目录的核心类库，例如：rt.jar、charsets.jar。
- 扩展类加载器：负责加载支撑JVM运行的位于JRE的lib目录ext扩展目录中的JAR类包
- 应用程序类加载器：负责加载ClassPath(项目路径)下的类包，主要就是加载你自己写的类
- 自定义类加载器：负责加载用户自定义路径下的类包

JVM启动类：sun.mics.Luancher --> getClassloader()

## 三、双亲委派模型

BootstrapClassLoader --> BootstrapClassLoader 是由C++代码实现

ExtClassLoader -->静态类

AppClassLoader -->静态类

![](https://i.loli.net/2020/11/18/I4lnHTidGJ76NbZ.png)

在**第一次**加载的时候会委派给父加载器，父加载器加载失败会再由子类去加载。**第二次**加载的时候会直接从**应用程序类加载器**去获取加载的类。

**注意**：父加载器不是父类，它们是组合关系。

### 双亲委派模型的好处：

**沙箱安全机制**：防止核心 API库被随意篡改。

例如，我们自己也写了一个👁java.lang.String类，在加载的时候，AppClassLoader会委托给ExtClassLoader，然后再由BootstrapClassLoader去加载👍**JDK路径下的java.lang.String**，直接由BootstrapClassLoader返回。因为是双亲委派机制，优先给父加载器去加载。结果是加载失败，会报一个Java安全异常。

### 打破双亲委派机制

概念：可以理解为当需要加载类的时候，子加载器不会再向上委托，而是选择自己加载类。

注意，如果打破双亲委派模型，可以把用一个类去继承ClassLoad方法并重写loadClass方法，将加载策略改成：如果该类没有被加载，先让当前的类加载器去加载，如果无法加载，则再提交给父类加载器去加载。

```java
protected Class<?> loadClass(String name, boolean resolve)
 throws ClassNotFoundException {
    synchronized (getClassLoadingLock(name)) {
        // First, check if the class has already been loaded
        Class<?> c = findLoadedClass(name);

        if (c == null) {
            // If still not found, then invoke findClass in order
            // to find the class.
            long t1 = System.nanoTime();
            c = findClass(name);

            // this is the defining class loader; record the stats
            sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);
            sun.misc.PerfCounter.getFindClasses().increment();
        }
        if (resolve) {
            resolveClass(c);
        }
        return c;
    }
 }

```

## 四、JMM（Java内存模型）

用来屏蔽各种硬件和各种操作系统的内存访问查一，以实现Java程序再各种平台能够达到一致内存访问效果。

Java内存模型规定所有变量都存储在**主内存(Main Memory)**中。每个线程都有自己的**工作内存（Working memory）**，工作内存保存线程使用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，不能直接读写主内存中的变量。不同步线程之间也无法直接访问对方的工作内存中的变量，线程间的变量值传递需要通过主内存来完成。

![](https://i.loli.net/2020/11/18/cTz51PyuiHpfbAS.png)

## 五、synchronized实现原理

使用**monitorenter**和**monitorexit**指令实现的：

- monitorenter指令是在编译后插入到同步代码块的开始位置，而monitorexit是插入到方法结束处和异常处

- 每个monitorenter必须有对应的monitorexit与之配对

- 任何对象都有一个monitor与之关联，当且一个monitor被持有后，它将处于锁定状态

在执行monitorenter指令时，首先尝试去获取对象的锁。如果对象没有被锁，或当前线程已获得该对象锁，把锁的计数器加1，相应的，执行monitorexit指令时，会将锁计数器减1，当计数器为0时，锁被释放。如果获取对象失败，那么线程就会进入**阻塞状态**，直到对象锁被另一个线程释放。

## 六、Thread线程状态

- [x] **新建（NEW）**：创建后尚未启动的线程处于这种状态
- [x] **运行（Runable）**：Runable包括了操作系统线程状态中的Running和Ready，也就是处于此状态的线程有可能正在执行，也很有可能正在等待着CPU为他分配执行时间。
- [x] **无限期等待（Waiting）**：处于这种状态的线程不会被分配CPU执行时间，它们要等待被其他线程显示地唤醒。
  - 没有设置TimeOut参数的Object.wait()方法。
  - 没有设置TImeOut参数的Threa.join()方法。
  - LockSupport.park()方法。
- [x] **期限等待（Timed Waiting）**：处于这种状态的线程也不会被分配CPU执行时间，不过无须等待被其他线程显示的唤醒。
- [x] **阻塞（Blocked）**：一个线程因为等待临界区的锁被阻塞产生的状态，与等待的区别是："阻塞状态"在等待获取一个排他锁。“等待状态”则线程是在等待一段时间进入同步区域，等待被唤醒。
- [x] **结束（Terminated）**：线程运行结束，运行完 run( )。

**Java中线程状态关系图**：

![](https://i.loli.net/2020/11/18/Ty9SlIU3N2HzZgC.png)

------

## 七、锁的优化--基于Synchronized

### 自旋锁与自适应自旋

**自旋锁**：如果有空闲的CPU能过够使线程同时并行执行，就可以让请求锁的线程“等一下”，但不需要放弃CPU的执行时间，观察持有锁的线程是否会很快释放锁，让线程执行一个忙循环（自选），这就是自旋锁。

**自适应自旋**：如果在同一个锁对象上，线程A经过自选而获得过锁，并且持有锁的线程B正在执行，JVM就会认为线程A经过自旋等待，可能会在次获得锁，会允许线程A做相对较长时间的自旋。如果线程A经过自旋等待，从未获得过锁，那么JVM就会将线程A的自旋过程忽略掉，也就是不允许自旋等待。这就是自适应自旋。

**Java 对象头（Mark Word）**

<img src="https://i.loli.net/2020/11/18/YgpKO5wCcRmJt1S.png" style="zoom:150%;" />

**偏向锁轻量级锁的状态转换**

![](https://i.loli.net/2020/11/18/vc7j4lPHR3o5ZBx.png)

### 偏向锁

定义：偏向锁即“偏向”获得该锁的第一个线程，“偏向”：线程获得该锁后，如果该锁没有被其他线程获取，那么持有偏向锁的线程不需要再**同步**。

注：同步--不需要再次修改对象头标志位等的操作，可以直接进入同步代码块。

原理：当对象第一次被线程获取，JVM将对象头中标志位设置为 **“ 01 ”** 即**偏向模式**，同时，使用**CAS**操作把 **取到锁的线程ID** 记录到对象的Mark Word中，如果CAS操作成功，持有偏向锁的线程进入锁相关的代码块是，JVM不需要进行任何同步操作。

**锁升级**：当有另一个线程去尝试获取对象的锁时，如果对象的锁定状态已经为偏向锁状态，根据对象目前是否位锁定状态，JVM**撤销偏向锁**状态后恢复到未锁定（标志位设置为 **“ 01”** ）或者**轻量级锁**状态（标志位设置为 **“ 00 ”** ），将**对象的Mark Word** 更新为指向 **Lock Record** 的**指针**。

### 轻量级锁

作用：减少传统重量级锁使用操作系统互斥变量产生的性能消耗。

原理：JVM首先会在当前线程的栈帧中建立一个名为**锁记录（Lock Record）**的空间，用于存储对象目前的 **Mark Word** 的拷贝。然后，JVM将使用**CAS**操作尝试将**对象的Mark Word** 更新为指向 **Lock Record** 的**指针**。

 * 如果更新成功，说明当前线程获得了该对象锁，并将对象头的**锁标志位**设置成 **“ 00 ”**，**表示此对象处于轻量级锁定状态**。
 * 如果更新失败，JVM检查对象的Mark Word 是否指向当前线程的栈帧，如果是则说明当前线程已经拥有对象锁，可以进入同步快继续执行，否则说明已经被其他线程抢占。

**锁升级**：如果有两个以上的线程争抢同一个锁**，轻量级锁**就会**膨胀**，升级为**重量级锁**，**锁标志位**状态值变为 **“ 10 ”**，Mark Word 存贮的就是指向**重量级锁**的**指针**



## 八、对象实例化过程

![](https://i.loli.net/2020/11/18/vc7j4lPHR3o5ZBx.png)

### 1、类加载检查（验证）

​	JVM遇到 new 指令使，首先去检查这个指令的参数是否能在常量池中定位到一个类的符号运用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，则执行类加载过程。

### 2、分配内存（准备）

​	在类检查通过后，接下来JVM将为新生对象分配内存，对想所需内存的大小在类加载完成后便可以确定，为对象分配空间的任务等同于把一块确定大小的内存从Java Heap 中划分出来。

​	**划分内存方法：**
​         🎈 **"指针碰撞（Bump the Pointer）"**：如果Java Heap 中内存是规整的，所有用过的内存和空闲的内存各分一边，中间放着一个指针作为分界点的指示器，当新建对象时，会将指针向空间内存那边移动至可容纳对象大小的位置。

​		⭐**“空闲列表（Free List）”**：如果Java Heap 中内存不是规整的，已使用的内存空间和 闲置的内存空间交错，JVM会去维护一个列表，记录可用的内存空间，在给对象分配内存时，会从列表中找到一块足够大的空间划分给对象实例，并更新空闲列表的记录。

#### **解决并发问题的方法：**

##### 	CAS（compare and swap） 

​		虚拟机采用CAS配上失败重试的方式保证更新操作的原子性来对分配内存空间的动作进行同步处理。 

##### 	本地线程分配缓冲（Thread Local Allocation Buffer,TLAB） 

​		把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存。通过­ XX:+/­ - UseTLAB 参数来设定虚拟机是否使用 TLAB (JVM会默认开启­XX:+UseTLAB)，­XX:TLABSize 指定TLAB大小。

### 3、设置初始值（还是属于准备阶段）

​	内存分配完成后，虚拟机需要将分配到的内存空间都初始化为**零值**（不包括对象头）， 如果使用TLAB，这一工作过程也 可以提前至TLAB分配时进行。这一步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问 到这些字段的数据类型所对应的零值。

### 4、设置<font color="red">对象头</font>

​	初始化零值之后，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。这些信息存放在对象的对象头**Object Header**之中。

### 5.执行方法 

​	执行<clinit>、<init>方法，即对象按照程序员的意愿进行初始化。对应到语言层面上讲，就是为属性赋值（注意，这与上面的赋 零值不同，这是由程序员赋的值），和执行构造方法。

## 对象在Eden区分配 

​	大多数情况下，对象在**新生代**中 **Eden** 区分配。当 Eden 区没有足够空间进行分配时，虚拟机将发起一次**Minor GC**。

- **Minor GC/Young GC**：指发生新生代的的垃圾收集动作，Minor GC非常频繁，回收速度一般也比较快。 

- **Major GC/Full GC**：一般会回收老年代 ，年轻代，方法区的垃圾，Major GC的速度一般会比Minor GC的慢 10倍以上。

  

  ### 对象动态年龄判断 

  ​	当前放对象的Survivor区域里(其中一块区域，放对象的那块s区)，一批对象的总大小大于这块Survivor区域内存大小的 50%(-XX:TargetSurvivorRatio可以指定)，那么此时大于等于这批对象年龄最大值的对象，就可以直接进入老年代了， 例如Survivor区域里现在有一批对象，年龄1+年龄2+年龄n的多个年龄对象总和超过了Survivor区域的50%，此时就会 把年龄n(含)以上的对象都放入老年代。这个规则其实是希望那些可能是长期存活的对象，尽早进入老年代。**对象动态年 龄判断机制一般是在minor gc之后触发的。**

### 大对象直接进入

老年代 大对象就是需要大量连续内存空间的对象（比如：字符串、数组）。

JVM参数 -**XX:PretenureSizeThreshold** 可以设置大 对象的大小，如果对象超过设置大小会直接进入老年代，不会进入年轻代，这个参数只在 **Serial** 和**ParNew**两个收集器下 有效。 

比如设置JVM参数：-**XX:PretenureSizeThreshold**=1000000 (单位是字节) -XX:+**UseSerialGC** ，再执行下上面的第一 个程序会发现大对象直接进了老年代 为什么要这样呢？ 为了避免为大对象分配内存时的复制操作而降低效率。

------

## 九、垃圾收集算法

### 标记-复制算法

​		为了解决效率问题，“复制”收集算法出现了。它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的 内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对 内存区间的一半进行回收。

![img](https://i.loli.net/2020/11/18/d9RDGxOcy7eiaNt.png)

### 标记-清除算法

​		算法分为“**标记**”和“**清除**”阶段：标记存活的对象， 统一回收所有未被标记的对象(一般选择这种)；也可以反过来，标 记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象 。它是最基础的收集算法，比较简单，但是会带来 两个明显的问题：

   1. 效率问题 (如果需要标记的对象太多，效率不高) 

   2. 空间问题（标记清除后会产生大量不连续的碎片）

      ![](https://i.loli.net/2020/11/18/4PDNzdCcMZsevHR.png)

### 标记-整理算法

​		根据老年代的特点特出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，<font color="red">而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存</font>。

![](https://i.loli.net/2020/11/18/beiopDrM8dR1Fgj.png)

## 十、垃圾收集器

![](https://i.loli.net/2020/11/18/lAKSP6HuiqzZRfI.png)

**如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。**

